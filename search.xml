<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性结构（笔记）]]></title>
    <url>%2F2020%2F01%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[线性表抽象数据类型描述1、List MakeEmpty()：初始化一个空线性表L；2、ElementType FindKth( int K, List L )：根据位序K，返回相应元素 ；3、int Find( ElementType X, List L )：在线性表L中查找X的第一次出现位置；4、void Insert( ElementType X, int i, List L)：在位序i前插入一个新元素X；5、void Delete( int i, List L )：删除指定位序i的元素；6、int Length( List L )：返回线性表L的长度n。 线性表的顺序存储实现12345typedef struct&#123; ElementType Data[MAXSIZE]; int Last; &#125; List; List L, *PtrL; 初始化（建立空的顺序表）12345LIst *MakeEmpty()&#123; List *PtrL; PtrL = (List *)malloc( sizeof(List)); PtrL-&gt;Last = -1; return PtrL; 查找查找成功的平均比较次数为(n+1)/2,平均时间性能为O(n)1234567int Find( ElementType X, List *PtrL ) &#123; int i = 0; while( i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X ) i++; if (i &gt; PtrL-&gt;Last) return -1; /* 如果没找到，返回-1 */ else return i; /* 找到后返回的是存储位置 */ &#125; 插入（第i(1≤i≤n+1)个位置插入一个值为X的新元素）平均移动次数为n/2,平均时间性能为O(n)12345678910111213141516int Insert( ElementType X, int i, List *PtrL ) &#123; int j; if(PtrL-&gt;Last == MAXSIZE-1)&#123; printf(&quot;表满&quot;); return; &#125; if(i&lt;1 || i&gt;PtrLL-&gt;Last+2)&#123; printf(&quot;位置不合法&quot;); return; &#125; for(j = PtrL-&gt;Last; j&gt;=i-1;j--) PtrL-&gt;Data[j+1] = PtrL-&gt;Data[j]; /*将 ai～ an倒序向后移动*/ PtrL-&gt;Data[i-1] = X; /*新元素插入*/ PtrL-&gt;Last++; /*Last仍指向最后元素*/ return; &#125; 删除（删除表的第 i (1≤i≤n)个位置上的元素)平均移动次数为(n-1)/2,平均时间性能为O(n)1234567891011void Delete( int i, List *PtrL ) &#123; int j; if( i &lt; 1 || i &gt; PtrL-&gt;Last+1 ) &#123; /*检查空表及删除位置的合法性*/ printf (“不存在第%d个元素”, i ); return ; &#125; for ( j = i; j &lt;= PtrL-&gt;Last; j++ ) PtrL-&gt;Data[j-1] = PtrL-&gt;Data[j]; /*将 ai+1～ an顺序向前移动*/ PtrL-&gt;Last--; /*Last仍指向最后元素*/ return;&#125; 线性表的链式存储实现12345typedef struct Node&#123; ElementType Data; struct Node *Next; &#125; List; List L, *PtrL; 求表长时间性能为O(n)123456789int Length (List *PtrL)&#123; List *p = PtrL; /*P指向表的第一个结点*/ int j = 0; while(p)&#123; p = p-&gt;Next; j++; /*当前P指向的第j个结点*/ &#125; return j;&#125; 查找平均时间性能为O(n)（1）按序号查找：FindKth;12345678910List *FindKth( int K, List *PtrL ) &#123; List *p = PtrL; int i = 1; while (p !=NULL &amp;&amp; i &lt; K )&#123; p = p-&gt;Next; i++; &#125; if ( i == K ) return p; /* 找到第K个，返回指针 */ else return NULL; /* 否则返回空 */ &#125; （2）按值查找：Find;123456List *Find( ElementType X, List *PtrL )&#123; List *p = PtrL; while ( p!=NULL &amp;&amp; p-&gt;Data != X ) p = p-&gt;Next; return p; &#125; 插入（在第 i-1(1≤i≤n+1)个结点后插入一个值为X的新结点)（1）先构造一个新结点，用s指向；（2）再找到链表的第 i-1个结点，用p指向；（3）然后修改指针，插入结点 ( p之后插入新结点是 s)平均查找次数为n/2,平均时间性能为O(n)1234567891011121314151617181920List *Insert( ElementType X, int i, List *PtrL ) &#123; List *p, *s; if ( i == 1 ) &#123; /* 新结点插入在表头 */ s = (List *)malloc(sizeof(List)); /*申请、填装结点*/ s-&gt;Data = X; s-&gt;Next = PtrL; return s; /*返回新表头指针*/ &#125; p = FindKth( i-1, PtrL ); /* 查找第i-1个结点 */ if ( p == NULL ) &#123; /* 第i-1个不存在，不能插入 */ printf(＂参数i错＂); return NULL; &#125;else &#123; s = (List *)malloc(sizeof(List)); /*申请、填装结点*/ s-&gt;Data = X; s-&gt;Next = p-&gt;Next; /*新结点插入在第i-1个结点的后面*/ p-&gt;Next = s; return PtrL; &#125; &#125; 删除（删除链表的第 i (1≤i≤n)个位置上的结点)（1）先找到链表的第 i-1个结点，用p指向；（2）再用指针s指向要被删除的结点（p的下一个结点）;（3）然后修改指针，删除s所指结点;（4）最后释放s所指结点的空间。平均查找次数为n/2,平均时间性能为O(n)123456789101112131415161718192021List *Delete( int i, List *PtrL ) &#123; List *p, *s; if ( i == 1 ) &#123; /* 若要删除的是表的第一个结点 */ s = PtrL; /*s指向第1个结点*/ if (PtrL!=NULL) PtrL = PtrL-&gt;Next; /*从链表中删除*/ else return NULL; free(s); /*释放被删除结点 */ return PtrL; &#125; p = FindKth( i-1, PtrL ); /*查找第i-1个结点*/ if ( p == NULL ) &#123; printf(“第%d个结点不存在”, i-1); return NULL; &#125; else if ( p-&gt;Next == NULL )&#123; printf(“第%d个结点不存在”, i); return NULL; &#125; else &#123; s = p-&gt;Next; /*s指向第i个结点*/ p-&gt;Next = s-&gt;Next; /*从链表中删除*/ free(s); /*释放被删除结点 */ return PtrL; &#125; &#125; #堆栈中缀表达式：运算符号位于两个运算数之间。如 ，a+bc-d/e 后缀表达式：运算符号位于两个运算数之后。如， abc+de/- ##堆栈的抽象数据类型描述堆栈（Stack）：具有一定操作约束的线性表只在一端（栈顶，Top）做 插入、删除 插入数据：入栈（Push） 删除数据：出栈（Pop） 后入先出：Last In First Out（LIFO）1、Stack CreateStack( int MaxSize )： 生成空堆栈，其最大长度为MaxSize；2、int IsFull( Stack S, int MaxSize )：判断堆栈S是否已满；3、void Push( Stack S, ElementType item )：将元素item压入堆栈；4、int IsEmpty ( Stack S )：判断堆栈S是否为空；5、ElementType Pop( Stack S )：删除并返回栈顶元素； Push 和 Pop 可以穿插交替进行 ##栈的顺序存储实现12345#define MaxSize &lt;储存数据元素的最大个数&gt;typedef struct &#123; ElementType Data[MaxSize]; int Top;&#125; Stack; ###入栈12345678void Push( Stack *PtrS, ElementType item )&#123; if ( PtrS-&gt;Top == MaxSize-1 ) &#123; printf(“堆栈满”); return; &#125;else &#123; PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; return; &#125;&#125; ###出栈1234567ElementType Pop( Stack *PtrS )&#123; if ( PtrS-&gt;Top == -1 ) &#123; printf(“堆栈空”); return ERROR; /* ERROR是ElementType的特殊值，标志错误 */ &#125; else return ( PtrS-&gt;Data[(PtrS-&gt;Top)--] );&#125; ##两个堆栈最大化利用数组空间两头向中间生长12345678#define MaxSize &lt;存储数据元素的最大个数&gt;struct DStack &#123; ElementType Data[MaxSize]; int Top1; /* 堆栈１的栈顶指针 */ int Top2; /* 堆栈２的栈顶指针 */&#125;S;S.Top1 = -1;S.Top2 = MaxSize; ###入栈12345678910void Push( struct DStack *PtrS, ElementType item, int Tag )&#123; /* Tag作为区分两个堆栈的标志，取值为1和2 */ if ( PtrS-&gt;Top2 – PtrS-&gt;Top1 == 1) &#123; /*堆栈满*/ printf(“堆栈满”); return ; &#125; if ( Tag == 1 ) /* 对第一个堆栈操作 */ PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item; else /* 对第二个堆栈操作 */ PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;&#125; ###出栈123456789101112ElementType Pop( struct DStack *PtrS, int Tag )&#123; /* Tag作为区分两个堆栈的标志，取值为1和2 */ if ( Tag == 1 ) &#123; /* 对第一个堆栈操作 */ if ( PtrS-&gt;Top1 == -1 ) &#123; /*堆栈1空 */ printf(“堆栈1空”); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top1)--]; &#125; else &#123; /* 对第二个堆栈操作 */ if ( PtrS-&gt;Top2 == MaxSize ) &#123; /*堆栈2空 */ printf(“堆栈2空”); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; &#125;&#125; ##堆栈的链式存储实现typedef struct Node{ ElementType Data; struct Node Next;} LinkStack;LinkStack Top;(1) 堆栈初始化（建立空栈） (2) 判断堆栈S是否为空 ###创建链栈1234567891011LinkStack *CreateStack()&#123; /* 构建一个堆栈的头结点，返回指针 */ LinkStack *S; S = malloc( sizeof(struct Node )); S-&gt;Next = NULL; return S;&#125;int IsEmpty( LinkStack *S )&#123; /*判断堆栈S是否为空，若为空函数返回整数 1，否则返回0 */ return ( S-&gt;Next == NULL );&#125; ###入栈12345678void Push( ElementType item, LinkStack *S )&#123; /* 将元素item压入堆栈S */ struct Node *TmpCell; TmpCell = malloc( sizeof( struct Node ) ); TmpCell-&gt;Element = item; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell;&#125; ###出栈1234567891011121314ElementType Pop( LinkStack *S )&#123; /* 删除并返回堆栈S的栈顶元素 */ struct Node *FirstCell; ElementType TopElem; if( IsEmpty( S ) ) &#123; printf(“堆栈空”); return NULL; &#125; else &#123; FirstCell = S-&gt;Next; S-&gt;Next = FirstCell-&gt;Next; TopElem = FirstCell -&gt;Element; free(FirstCell); return TopElem; &#125;&#125; #队列 ##队列的抽象数据类型描述队列(Queue)：具有一定操作约束的线性表  插入和删除操作：只能在一端插入，而在另一端删除。 数据插入：入队列（AddQ） 数据删除：出队列（DeleteQ） 先来先服务 先进先出：FIFO1、Queue CreatQueue( int MaxSize )：生成长度为MaxSize的空队列；2、int IsFullQ( Queue Q, int MaxSize )：判断队列Q是否已满；3、void AddQ( Queue Q, ElementType item )： 将数据元素item插入队列Q中；4、int IsEmptyQ( Queue Q )： 判断队列Q是否为空；5、ElementType DeleteQ( Queue Q )：将队头数据元素从队列中删除并返回。 ##队列的顺序存储实现123456#define MaxSize &lt;储存数据元素的最大个数&gt; typedef struct &#123; ElementType Data[ MaxSize ]; int rear; int front;&#125; Queue; ###入队列12345678void AddQ( Queue *PtrQ, ElementType item)&#123; if ( (PtrQ-&gt;rear+1) % MaxSize == PtrQ-&gt;front ) &#123; printf(“队列满”); return; &#125; PtrQ-&gt;rear = (PtrQ-&gt;rear+1)% MaxSize; PtrQ-&gt;Data[PtrQ-&gt;rear] = item;&#125; ###出队列12345678910ElementType DeleteQ ( Queue *PtrQ ) &#123; if ( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123; printf(“队列空”); return ERROR; &#125; else &#123; PtrQ-&gt;front = (PtrQ-&gt;front+1)% MaxSize; return PtrQ-&gt;Data[PtrQ-&gt;front]; &#125;&#125; ##队列的链式结构存储实现123456789typedef struct Node&#123; ElementType Data; struct Node *Next;&#125;QNode; typedef struct &#123; /* 链队列结构 */ QNode *rear; /* 指向队尾结点 */ QNode *front; /* 指向队头结点 */&#125; LinkQueue;LinkQueue *PtrQ ; ##多项式加法运算1234567typedef struct PolyNode &#123; int coef; // 系数 int expon; // 指数 struct node *link; // 指向下一个节点的指针&#125;*Polynomial; Polynomial P1, P2; 1234567891011121314151617181920212223242526272829303132Polynomial PolyAdd (Polynomial P1, Polynomial P2)&#123; Polynomial front, rear, temp; int sum; rear = (Polynomial) malloc(sizeof(PolyNode)); front = rear; /* 由front 记录结果多项式链表头结点 */ while ( P1 &amp;&amp; P2 ) /* 当两个多项式都有非零项待处理时 */ switch ( Compare(P1-&gt;expon, P2-&gt;expon) ) &#123; case 1: Attach( P1-&gt;coef, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; break; case -1: Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); P2 = P2-&gt;link; break; case 0: sum = P1-&gt;coef + P2-&gt;coef; if ( sum ) Attach(sum, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; P2 = P2-&gt;link; break; &#125; /* 将未处理完的另一个多项式的所有节点依次复制到结果多项式中去 */ for ( ; P1; P1 = P1-&gt;link ) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); for ( ; P2; P2 = P2-&gt;link ) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); rear-&gt;link = NULL; temp = front; front = front-&gt;link; /*令front指向结果多项式第一个非零项 */ free(temp); /* 释放临时空表头结点 */ return front; &#125; 1234567891011void Attach( int coef, int expon, Polynomial *PtrRear ) &#123; /* 由于在本函数中需要改变当前结果表达式尾项指针的值， */ /* 所以函数传递进来的是结点指针的地址，*PtrRear指向尾项*/ Polynomial P; P =(Polynomial)malloc(sizeof(PolyNode)); /* 申请新结点 */ P-&gt;coef = coef; /* 对新结点赋值 */ P-&gt;expon = expon; /* 将P指向的新结点插入到当前结果表达式尾项的后面 */ (*PtrRear)-&gt;link = P; *PtrRear = P; /* 修改PtrRear值 */&#125;]]></content>
      <categories>
        <category>data Structure</category>
      </categories>
      <tags>
        <tag>data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性结构（笔记）]]></title>
    <url>%2F2020%2F01%2F03%2F%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线性表抽象数据类型描述1、List MakeEmpty()：初始化一个空线性表L；2、ElementType FindKth( int K, List L )：根据位序K，返回相应元素 ；3、int Find( ElementType X, List L )：在线性表L中查找X的第一次出现位置；4、void Insert( ElementType X, int i, List L)：在位序i前插入一个新元素X；5、void Delete( int i, List L )：删除指定位序i的元素；6、int Length( List L )：返回线性表L的长度n。 线性表的顺序存储实现12345typedef struct&#123; ElementType Data[MAXSIZE]; int Last; &#125; List; List L, *PtrL; 初始化（建立空的顺序表）12345LIst *MakeEmpty()&#123; List *PtrL; PtrL = (List *)malloc( sizeof(List)); PtrL-&gt;Last = -1; return PtrL; 查找查找成功的平均比较次数为(n+1)/2,平均时间性能为O(n)1234567int Find( ElementType X, List *PtrL ) &#123; int i = 0; while( i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X ) i++; if (i &gt; PtrL-&gt;Last) return -1; /* 如果没找到，返回-1 */ else return i; /* 找到后返回的是存储位置 */ &#125; 插入（第i(1≤i≤n+1)个位置插入一个值为X的新元素）平均移动次数为n/2,平均时间性能为O(n)12345678910111213141516int Insert( ElementType X, int i, List *PtrL ) &#123; int j; if(PtrL-&gt;Last == MAXSIZE-1)&#123; printf(&quot;表满&quot;); return; &#125; if(i&lt;1 || i&gt;PtrLL-&gt;Last+2)&#123; printf(&quot;位置不合法&quot;); return; &#125; for(j = PtrL-&gt;Last; j&gt;=i-1;j--) PtrL-&gt;Data[j+1] = PtrL-&gt;Data[j]; /*将 ai～ an倒序向后移动*/ PtrL-&gt;Data[i-1] = X; /*新元素插入*/ PtrL-&gt;Last++; /*Last仍指向最后元素*/ return; &#125; 删除（删除表的第 i (1≤i≤n)个位置上的元素)平均移动次数为(n-1)/2,平均时间性能为O(n)1234567891011void Delete( int i, List *PtrL ) &#123; int j; if( i &lt; 1 || i &gt; PtrL-&gt;Last+1 ) &#123; /*检查空表及删除位置的合法性*/ printf (“不存在第%d个元素”, i ); return ; &#125; for ( j = i; j &lt;= PtrL-&gt;Last; j++ ) PtrL-&gt;Data[j-1] = PtrL-&gt;Data[j]; /*将 ai+1～ an顺序向前移动*/ PtrL-&gt;Last--; /*Last仍指向最后元素*/ return;&#125; 线性表的链式存储实现12345typedef struct Node&#123; ElementType Data; struct Node *Next; &#125; List; List L, *PtrL; 求表长时间性能为O(n)123456789int Length (List *PtrL)&#123; List *p = PtrL; /*P指向表的第一个结点*/ int j = 0; while(p)&#123; p = p-&gt;Next; j++; /*当前P指向的第j个结点*/ &#125; return j;&#125; 查找平均时间性能为O(n)（1）按序号查找：FindKth;12345678910List *FindKth( int K, List *PtrL ) &#123; List *p = PtrL; int i = 1; while (p !=NULL &amp;&amp; i &lt; K )&#123; p = p-&gt;Next; i++; &#125; if ( i == K ) return p; /* 找到第K个，返回指针 */ else return NULL; /* 否则返回空 */ &#125; （2）按值查找：Find;123456List *Find( ElementType X, List *PtrL )&#123; List *p = PtrL; while ( p!=NULL &amp;&amp; p-&gt;Data != X ) p = p-&gt;Next; return p; &#125; 插入（在第 i-1(1≤i≤n+1)个结点后插入一个值为X的新结点)（1）先构造一个新结点，用s指向；（2）再找到链表的第 i-1个结点，用p指向；（3）然后修改指针，插入结点 ( p之后插入新结点是 s)平均查找次数为n/2,平均时间性能为O(n)1234567891011121314151617181920List *Insert( ElementType X, int i, List *PtrL ) &#123; List *p, *s; if ( i == 1 ) &#123; /* 新结点插入在表头 */ s = (List *)malloc(sizeof(List)); /*申请、填装结点*/ s-&gt;Data = X; s-&gt;Next = PtrL; return s; /*返回新表头指针*/ &#125; p = FindKth( i-1, PtrL ); /* 查找第i-1个结点 */ if ( p == NULL ) &#123; /* 第i-1个不存在，不能插入 */ printf(＂参数i错＂); return NULL; &#125;else &#123; s = (List *)malloc(sizeof(List)); /*申请、填装结点*/ s-&gt;Data = X; s-&gt;Next = p-&gt;Next; /*新结点插入在第i-1个结点的后面*/ p-&gt;Next = s; return PtrL; &#125; &#125; 删除（删除链表的第 i (1≤i≤n)个位置上的结点)（1）先找到链表的第 i-1个结点，用p指向；（2）再用指针s指向要被删除的结点（p的下一个结点）;（3）然后修改指针，删除s所指结点;（4）最后释放s所指结点的空间。平均查找次数为n/2,平均时间性能为O(n)123456789101112131415161718192021List *Delete( int i, List *PtrL ) &#123; List *p, *s; if ( i == 1 ) &#123; /* 若要删除的是表的第一个结点 */ s = PtrL; /*s指向第1个结点*/ if (PtrL!=NULL) PtrL = PtrL-&gt;Next; /*从链表中删除*/ else return NULL; free(s); /*释放被删除结点 */ return PtrL; &#125; p = FindKth( i-1, PtrL ); /*查找第i-1个结点*/ if ( p == NULL ) &#123; printf(“第%d个结点不存在”, i-1); return NULL; &#125; else if ( p-&gt;Next == NULL )&#123; printf(“第%d个结点不存在”, i); return NULL; &#125; else &#123; s = p-&gt;Next; /*s指向第i个结点*/ p-&gt;Next = s-&gt;Next; /*从链表中删除*/ free(s); /*释放被删除结点 */ return PtrL; &#125; &#125; #堆栈中缀表达式：运算符号位于两个运算数之间。如 ，a+bc-d/e 后缀表达式：运算符号位于两个运算数之后。如， abc+de/- ##堆栈的抽象数据类型描述堆栈（Stack）：具有一定操作约束的线性表只在一端（栈顶，Top）做 插入、删除 插入数据：入栈（Push） 删除数据：出栈（Pop） 后入先出：Last In First Out（LIFO）1、Stack CreateStack( int MaxSize )： 生成空堆栈，其最大长度为MaxSize；2、int IsFull( Stack S, int MaxSize )：判断堆栈S是否已满；3、void Push( Stack S, ElementType item )：将元素item压入堆栈；4、int IsEmpty ( Stack S )：判断堆栈S是否为空；5、ElementType Pop( Stack S )：删除并返回栈顶元素； Push 和 Pop 可以穿插交替进行 ##栈的顺序存储实现12345#define MaxSize &lt;储存数据元素的最大个数&gt;typedef struct &#123; ElementType Data[MaxSize]; int Top;&#125; Stack; ###入栈12345678void Push( Stack *PtrS, ElementType item )&#123; if ( PtrS-&gt;Top == MaxSize-1 ) &#123; printf(“堆栈满”); return; &#125;else &#123; PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; return; &#125;&#125; ###出栈1234567ElementType Pop( Stack *PtrS )&#123; if ( PtrS-&gt;Top == -1 ) &#123; printf(“堆栈空”); return ERROR; /* ERROR是ElementType的特殊值，标志错误 */ &#125; else return ( PtrS-&gt;Data[(PtrS-&gt;Top)--] );&#125; ##两个堆栈最大化利用数组空间两头向中间生长12345678#define MaxSize &lt;存储数据元素的最大个数&gt;struct DStack &#123; ElementType Data[MaxSize]; int Top1; /* 堆栈１的栈顶指针 */ int Top2; /* 堆栈２的栈顶指针 */&#125;S;S.Top1 = -1;S.Top2 = MaxSize; ###入栈12345678910void Push( struct DStack *PtrS, ElementType item, int Tag )&#123; /* Tag作为区分两个堆栈的标志，取值为1和2 */ if ( PtrS-&gt;Top2 – PtrS-&gt;Top1 == 1) &#123; /*堆栈满*/ printf(“堆栈满”); return ; &#125; if ( Tag == 1 ) /* 对第一个堆栈操作 */ PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item; else /* 对第二个堆栈操作 */ PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;&#125; ###出栈123456789101112ElementType Pop( struct DStack *PtrS, int Tag )&#123; /* Tag作为区分两个堆栈的标志，取值为1和2 */ if ( Tag == 1 ) &#123; /* 对第一个堆栈操作 */ if ( PtrS-&gt;Top1 == -1 ) &#123; /*堆栈1空 */ printf(“堆栈1空”); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top1)--]; &#125; else &#123; /* 对第二个堆栈操作 */ if ( PtrS-&gt;Top2 == MaxSize ) &#123; /*堆栈2空 */ printf(“堆栈2空”); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; &#125;&#125; ##堆栈的链式存储实现typedef struct Node{ ElementType Data; struct Node Next;} LinkStack;LinkStack Top;(1) 堆栈初始化（建立空栈） (2) 判断堆栈S是否为空 ###创建链栈1234567891011LinkStack *CreateStack()&#123; /* 构建一个堆栈的头结点，返回指针 */ LinkStack *S; S = malloc( sizeof(struct Node )); S-&gt;Next = NULL; return S;&#125;int IsEmpty( LinkStack *S )&#123; /*判断堆栈S是否为空，若为空函数返回整数 1，否则返回0 */ return ( S-&gt;Next == NULL );&#125; ###入栈12345678void Push( ElementType item, LinkStack *S )&#123; /* 将元素item压入堆栈S */ struct Node *TmpCell; TmpCell = malloc( sizeof( struct Node ) ); TmpCell-&gt;Element = item; TmpCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell;&#125; ###出栈1234567891011121314ElementType Pop( LinkStack *S )&#123; /* 删除并返回堆栈S的栈顶元素 */ struct Node *FirstCell; ElementType TopElem; if( IsEmpty( S ) ) &#123; printf(“堆栈空”); return NULL; &#125; else &#123; FirstCell = S-&gt;Next; S-&gt;Next = FirstCell-&gt;Next; TopElem = FirstCell -&gt;Element; free(FirstCell); return TopElem; &#125;&#125; #队列 ##队列的抽象数据类型描述队列(Queue)：具有一定操作约束的线性表  插入和删除操作：只能在一端插入，而在另一端删除。 数据插入：入队列（AddQ） 数据删除：出队列（DeleteQ） 先来先服务 先进先出：FIFO1、Queue CreatQueue( int MaxSize )：生成长度为MaxSize的空队列；2、int IsFullQ( Queue Q, int MaxSize )：判断队列Q是否已满；3、void AddQ( Queue Q, ElementType item )： 将数据元素item插入队列Q中；4、int IsEmptyQ( Queue Q )： 判断队列Q是否为空；5、ElementType DeleteQ( Queue Q )：将队头数据元素从队列中删除并返回。 ##队列的顺序存储实现123456#define MaxSize &lt;储存数据元素的最大个数&gt; typedef struct &#123; ElementType Data[ MaxSize ]; int rear; int front;&#125; Queue; ###入队列12345678void AddQ( Queue *PtrQ, ElementType item)&#123; if ( (PtrQ-&gt;rear+1) % MaxSize == PtrQ-&gt;front ) &#123; printf(“队列满”); return; &#125; PtrQ-&gt;rear = (PtrQ-&gt;rear+1)% MaxSize; PtrQ-&gt;Data[PtrQ-&gt;rear] = item;&#125; ###出队列12345678910ElementType DeleteQ ( Queue *PtrQ ) &#123; if ( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123; printf(“队列空”); return ERROR; &#125; else &#123; PtrQ-&gt;front = (PtrQ-&gt;front+1)% MaxSize; return PtrQ-&gt;Data[PtrQ-&gt;front]; &#125;&#125; ##队列的链式结构存储实现123456789typedef struct Node&#123; ElementType Data; struct Node *Next;&#125;QNode; typedef struct &#123; /* 链队列结构 */ QNode *rear; /* 指向队尾结点 */ QNode *front; /* 指向队头结点 */&#125; LinkQueue;LinkQueue *PtrQ ; ##多项式加法运算1234567typedef struct PolyNode &#123; int coef; // 系数 int expon; // 指数 struct node *link; // 指向下一个节点的指针&#125;*Polynomial; Polynomial P1, P2; 1234567891011121314151617181920212223242526272829303132Polynomial PolyAdd (Polynomial P1, Polynomial P2)&#123; Polynomial front, rear, temp; int sum; rear = (Polynomial) malloc(sizeof(PolyNode)); front = rear; /* 由front 记录结果多项式链表头结点 */ while ( P1 &amp;&amp; P2 ) /* 当两个多项式都有非零项待处理时 */ switch ( Compare(P1-&gt;expon, P2-&gt;expon) ) &#123; case 1: Attach( P1-&gt;coef, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; break; case -1: Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); P2 = P2-&gt;link; break; case 0: sum = P1-&gt;coef + P2-&gt;coef; if ( sum ) Attach(sum, P1-&gt;expon, &amp;rear); P1 = P1-&gt;link; P2 = P2-&gt;link; break; &#125; /* 将未处理完的另一个多项式的所有节点依次复制到结果多项式中去 */ for ( ; P1; P1 = P1-&gt;link ) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear); for ( ; P2; P2 = P2-&gt;link ) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear); rear-&gt;link = NULL; temp = front; front = front-&gt;link; /*令front指向结果多项式第一个非零项 */ free(temp); /* 释放临时空表头结点 */ return front; &#125; 1234567891011void Attach( int coef, int expon, Polynomial *PtrRear ) &#123; /* 由于在本函数中需要改变当前结果表达式尾项指针的值， */ /* 所以函数传递进来的是结点指针的地址，*PtrRear指向尾项*/ Polynomial P; P =(Polynomial)malloc(sizeof(PolyNode)); /* 申请新结点 */ P-&gt;coef = coef; /* 对新结点赋值 */ P-&gt;expon = expon; /* 将P指向的新结点插入到当前结果表达式尾项的后面 */ (*PtrRear)-&gt;link = P; *PtrRear = P; /* 修改PtrRear值 */&#125;]]></content>
      <categories>
        <category>data Structure</category>
      </categories>
      <tags>
        <tag>data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql基本用法]]></title>
    <url>%2F2019%2F03%2F22%2FMysql%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[登录数据库mysql -hlocalhost -uroot -p; 修改密码mysqladmin -uroot -pold password new; 显示数据库show databases; 显示数据表show tables; 选择数据库use examples; 创建数据库并设置编码utf-8 多语言create database &#39;examples&#39; default character set utf8 collate utf8_general_ci; 删除数据库drop database examples; 创建表1234567create table test( id int(10) unsigned zerofill not null auto_increment, email varchar(40) not null, ip varchar(15) not null, state int(10) not null default &apos;-1&apos;, primary key (id))engine=InnoDB; 显示表结构describe 删除表drop table test； 重命名表alter table test_old rename test_new; 添加列alter table test add cn int(4) not null; 修改列alter table test change id id1 varchar(10) not null; 删除列alter table test drop cn; 创建索引alter table test add index (cn,id); 删除索引alter table test drop index cn 插入数据insert into test (id,email,ip,state) values(2,&#39;qq@qq.com&#39;,&#39;127.0.0.1&#39;,&#39;0&#39;); 删除数据delete from test where id = 1; 修改数据update test set id=&#39;1&#39;,email=&#39;q@qq.com&#39; where id=1; 查数据select * from test; 取所有数据select * from test limit 0,2; 取前两条数据select * from test email like &#39;%qq%&#39; 查含有qq字符 _表示一个 %表示多个select * from test order by id asc; 降序descselect * from test id not in(&#39;2&#39;,&#39;3&#39;); id不含2,3或者去掉not表示含有select * from test timer between 1 and 10; 数据在1,10之间]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog！]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
